<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <title>ESP32 SD Tool</title>
    <style>
      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        margin: 0;
        padding: 16px;
        background: #0f172a;
        color: #e5e7eb;
      }
      h1 {
        font-size: 1.4rem;
        margin-bottom: 12px;
      }
      .toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 12px;
      }
      button {
        padding: 6px 12px;
        border-radius: 6px;
        border: none;
        cursor: pointer;
        font-size: 0.9rem;
      }
      button.primary {
        background: #22c55e;
        color: #022c22;
        font-weight: 600;
      }
      button.secondary {
        background: #1f2937;
        color: #e5e7eb;
      }
      button.danger {
        background: #ef4444;
        color: #fee2e2;
      }
      button:disabled {
        opacity: 0.5;
        cursor: default;
      }
      #status {
        margin-top: 4px;
        font-size: 0.8rem;
        color: #9ca3af;
      }
      #files {
        margin-top: 12px;
        padding: 8px;
        border-radius: 6px;
        background: #020617;
        max-height: 200px;
        overflow-y: auto;
        font-size: 0.85rem;
      }
      .file-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        padding: 4px 0;
        border-bottom: 1px solid #111827;
      }
      .file-row:last-child {
        border-bottom: none;
      }
      .file-name {
        flex: 1;
        word-break: break-all;
      }
      #output {
        margin-top: 12px;
        padding: 8px;
        border-radius: 6px;
        background: #020617;
        min-height: 120px;
        max-height: 320px;
        overflow-y: auto;
        white-space: pre-wrap;
        font-size: 0.8rem;
        font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo,
          Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      }
    </style>
  </head>
  <body>
    <h1>ESP32 SD Browser (Web Serial)</h1>

    <div class="toolbar">
      <button id="btnConnect" class="primary">Conectar</button>
      <button id="btnDisconnect" class="secondary" disabled>Desconectar</button>
      <button id="btnList" class="secondary" disabled>LIST (SD)</button>
      <button id="btnDump" class="secondary" disabled>Dump SD → Folder</button>
    </div>

    <div id="status">Estado: desconectado</div>

    <div id="files"></div>

    <div id="output"></div>

    <script>
      // --- Estado global ---
      let port = null;
      let reader = null;
      let writer = null;
      let readLoopPromise = null;
      let buffer = "";

      let fileList = [];

      // Promesas para coordinar LIST y READ
      let waitForListResolve = null;
      let waitForFileResolve = null;
      let currentFileName = null;
      let currentFileContent = "";

      const statusEl = document.getElementById("status");
      const filesEl = document.getElementById("files");
      const outputEl = document.getElementById("output");

      const btnConnect = document.getElementById("btnConnect");
      const btnDisconnect = document.getElementById("btnDisconnect");
      const btnList = document.getElementById("btnList");
      const btnDump = document.getElementById("btnDump");

      function log(msg) {
        console.log(msg);
        outputEl.textContent += msg + "\n";
        outputEl.scrollTop = outputEl.scrollHeight;
      }

      function setStatus(text) {
        statusEl.textContent = "Estado: " + text;
      }

      function setConnectedUI(connected) {
        btnConnect.disabled = connected;
        btnDisconnect.disabled = !connected;
        btnList.disabled = !connected;
        btnDump.disabled = !connected;
      }

      async function connect() {
        try {
          if (!("serial" in navigator)) {
            alert("Este navegador no soporta Web Serial. Usa Chrome / Edge.");
            return;
          }

          port = await navigator.serial.requestPort();
          await port.open({ baudRate: 115200 });

          setStatus("conectado");
          setConnectedUI(true);
          log("Conectado al puerto serie.");

          const textDecoder = new TextDecoderStream();
          const readableStreamClosed = port.readable.pipeTo(
            textDecoder.writable
          );
          const inputStream = textDecoder.readable;
          reader = inputStream.getReader();

          const textEncoder = new TextEncoderStream();
          textEncoder.readable.pipeTo(port.writable);
          writer = textEncoder.writable.getWriter();

          readLoopPromise = readLoop();
        } catch (err) {
          console.error(err);
          setStatus("error al conectar");
          log("Error al conectar: " + err);
          port = null;
          reader = null;
          writer = null;
          setConnectedUI(false);
        }
      }

      async function disconnect() {
        try {
          if (reader) {
            await reader.cancel().catch(() => {});
            reader = null;
          }
          if (writer) {
            await writer.close().catch(() => {});
            writer = null;
          }
          if (port) {
            await port.close().catch(() => {});
            port = null;
          }
          setStatus("desconectado");
          setConnectedUI(false);
          log("Desconectado.");
        } catch (err) {
          console.error(err);
          log("Error al desconectar: " + err);
        }
      }

      async function sendCommand(cmd) {
        if (!writer) {
          throw new Error("No hay writer activo.");
        }
        const line = cmd.trim() + "\n";
        await writer.write(line);
        log(">> " + cmd);
      }

      async function readLoop() {
        buffer = "";
        while (port && reader) {
          try {
            const { value, done } = await reader.read();
            if (done) {
              break;
            }
            if (value) {
              buffer += value;
              let lines = buffer.split("\n");
              buffer = lines.pop(); // lo último puede ser parcial
              for (const l of lines) {
                handleIncomingLine(l.replace(/\r$/, ""));
              }
            }
          } catch (err) {
            console.error("Error en readLoop:", err);
            break;
          }
        }
        setStatus("desconectado (read loop terminado)");
        setConnectedUI(false);
      }

      function handleIncomingLine(line) {
        if (!line) return;

        // Manejo de protocolo
        if (line === "LIST_BEGIN") {
          fileList = [];
          log("<< LIST_BEGIN");
          return;
        }

        if (line === "LIST_END") {
          log("<< LIST_END");
          renderFileList();
          if (waitForListResolve) {
            waitForListResolve(fileList);
            waitForListResolve = null;
          }
          return;
        }

        if (line.startsWith("FILE_BEGIN:")) {
          currentFileName = line.substring("FILE_BEGIN:".length).trim();
          currentFileContent = "";
          log("<< FILE_BEGIN: " + currentFileName);
          return;
        }

        if (line.startsWith("FILE_END:")) {
          const endName = line.substring("FILE_END:".length).trim();
          log("<< FILE_END: " + endName);
          if (waitForFileResolve && currentFileName === endName) {
            // Resolver promesa de lectura de archivo
            waitForFileResolve({
              name: currentFileName,
              content: currentFileContent,
            });
            waitForFileResolve = null;
          } else {
            // Si no había promesa, mostramos contenido en output
            log("Contenido de " + endName + ":\n" + currentFileContent);
          }
          currentFileName = null;
          currentFileContent = "";
          return;
        }

        // Si estamos dentro de FILE_BEGIN / FILE_END, es contenido de archivo
        if (currentFileName !== null) {
          currentFileContent += line + "\n";
          return;
        }

        // Si no es nada especial, tratamos normal
        log("<< " + line);

        // Si estamos en modo LIST, las líneas entre BEGIN y END son nombres de archivo
        // pero ya lo controlamos al ver LIST_BEGIN / LIST_END arriba.
        // Aquí añadimos nombre de archivo si detectamos que estamos en un LIST activo.
        if (fileList !== null && waitForListResolve !== null) {
          // Heurística: durante LIST, las líneas normales se interpretan como nombres de archivo.
          // El ESP32 ya filtra directorios, así que asumimos que todo aquí son nombres válidos.
          fileList.push(line.trim());
        }
      }

      function renderFileList() {
        filesEl.innerHTML = "";
        if (!fileList || fileList.length === 0) {
          filesEl.textContent = "Sin archivos o LIST aún no ejecutado.";
          return;
        }

        for (const fname of fileList) {
          const row = document.createElement("div");
          row.className = "file-row";

          const nameEl = document.createElement("div");
          nameEl.className = "file-name";
          nameEl.textContent = fname;

          const btnRead = document.createElement("button");
          btnRead.textContent = "READ";
          btnRead.className = "secondary";
          btnRead.onclick = async () => {
            try {
              await readSingleFileAndShow(fname);
            } catch (err) {
              log("Error leyendo " + fname + ": " + err);
            }
          };

          row.appendChild(nameEl);
          row.appendChild(btnRead);
          filesEl.appendChild(row);
        }
      }

      // --- Helpers de alto nivel ---

      function listFiles() {
        return new Promise(async (resolve, reject) => {
          if (!port || !writer) {
            return reject(new Error("No conectado."));
          }
          waitForListResolve = resolve;
          try {
            await sendCommand("LIST");
          } catch (err) {
            waitForListResolve = null;
            reject(err);
          }
        });
      }

      function readFile(name) {
        return new Promise(async (resolve, reject) => {
          if (!port || !writer) {
            return reject(new Error("No conectado."));
          }
          waitForFileResolve = resolve;
          try {
            await sendCommand("READ " + name);
          } catch (err) {
            waitForFileResolve = null;
            reject(err);
          }
        });
      }

      async function readSingleFileAndShow(name) {
        const result = await readFile(name);
        log("===== Contenido de " + result.name + " =====");
        log(result.content);
      }

      async function dumpSdToFolder() {
        if (!("showDirectoryPicker" in window)) {
          alert(
            "Tu navegador no soporta File System Access API.\nUsa Chrome / Edge en escritorio."
          );
          return;
        }
        if (!port || !writer) {
          alert("Primero conecta al ESP32.");
          return;
        }

        try {
          const dirHandle = await window.showDirectoryPicker();
          log("Carpeta seleccionada para volcado de SD.");

          // 1) Obtener lista de archivos desde el ESP32
          log("Solicitando LIST a la SD...");
          const files = await listFiles();
          if (!files || files.length === 0) {
            log("No hay archivos en la SD.");
            return;
          }
          log("Archivos encontrados: " + files.join(", "));

          // 2) Leer cada archivo y grabarlo en la carpeta
          for (const fname of files) {
            log("Leyendo archivo: " + fname);
            const result = await readFile(fname);
            log("Escribiendo en el disco local: " + fname);
            const fileHandle = await dirHandle.getFileHandle(fname, {
              create: true,
            });
            const writable = await fileHandle.createWritable();
            await writable.write(result.content);
            await writable.close();
          }

          log("Volcado completado.");
          alert("Volcado completado. Revisa la carpeta que seleccionaste.");
        } catch (err) {
          console.error(err);
          log("Error en Dump SD → Folder: " + err);
        }
      }

      // --- Eventos UI ---
      btnConnect.onclick = () => connect();
      btnDisconnect.onclick = () => disconnect();

      btnList.onclick = async () => {
        try {
          await listFiles();
        } catch (err) {
          log("Error ejecutando LIST: " + err);
        }
      };

      btnDump.onclick = () => {
        dumpSdToFolder();
      };
    </script>
  </body>
</html>
