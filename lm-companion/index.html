<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>LineMaster 2.4GHz Companion</title>
    <style>
      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        margin: 0;
        padding: 16px;
        background: #f9fafb;
        color: #111827;
      }
      h1 {
        font-size: 1.6rem;
        margin-bottom: 12px;
      }
      .toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 12px;
      }
      button {
        padding: 8px 14px;
        border-radius: 6px;
        border: 1px solid #d1d5db;
        cursor: pointer;
        font-size: 0.95rem;
      }
      button.primary {
        background: #2563eb;
        color: #ffffff;
        font-weight: 600;
        border-color: #1d4ed8;
      }
      button.secondary {
        background: #ffffff;
        color: #111827;
      }
      button.danger {
        background: #ef4444;
        color: #ffffff;
        border-color: #dc2626;
      }
      button:disabled {
        opacity: 0.55;
        cursor: default;
      }
      #status {
        margin-top: 4px;
        font-size: 0.9rem;
        color: #4b5563;
      }
      #files {
        margin-top: 16px;
        padding: 12px;
        border-radius: 8px;
        background: #ffffff;
        border: 1px solid #e5e7eb;
        max-height: 220px;
        overflow-y: auto;
        font-size: 0.9rem;
      }
      .file-row {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 6px 0;
        border-bottom: 1px solid #e5e7eb;
      }
      .file-row:last-child {
        border-bottom: none;
      }
      .file-name {
        flex: 1;
        word-break: break-all;
      }
      #fileContent {
        margin-top: 16px;
        padding: 12px;
        border-radius: 8px;
        background: #ffffff;
        border: 1px solid #e5e7eb;
        min-height: 140px;
        max-height: 360px;
        overflow-y: auto;
        white-space: pre-wrap;
        font-size: 0.9rem;
        font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo,
          Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      }
      #fileContentTitle {
        font-weight: 600;
        margin-bottom: 8px;
      }
      /* Log panel (hidden by default) */
      #output {
        margin-top: 16px;
        padding: 10px;
        border-radius: 8px;
        background: #f3f4f6;
        border: 1px solid #e5e7eb;
        min-height: 80px;
        max-height: 240px;
        overflow-y: auto;
        white-space: pre-wrap;
        font-size: 0.85rem;
        font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo,
          Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        display: none; /* hidden by default */
      }
      .section-title {
        margin-top: 16px;
        margin-bottom: 4px;
        font-weight: 600;
        font-size: 0.95rem;
        color: #374151;
      }

      .topbar {
        background: #f9fafb;
        padding: 12px 16px;
        display: flex;
        align-items: center;
        gap: 16px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
      }

      .topbar .title {
        font-size: 1rem;
        font-weight: 600;
      }

      /* -------- Model editor styles -------- */
      .fieldset {
        border: 1px solid #e5e7eb;
        background: #fff;
        border-radius: 8px;
        padding: 12px;
        margin-top: 12px;
      }
      .fieldset-title {
        font-weight: 600;
        margin-bottom: 10px;
        color: #374151;
      }
      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 10px;
      }
      .field label {
        display: block;
        font-size: 0.85rem;
        color: #374151;
        margin-bottom: 4px;
      }
      .field input[type="number"],
      .field input[type="text"] {
        width: 100%;
        padding: 8px 10px;
        border: 1px solid #d1d5db;
        border-radius: 6px;
        font-size: 0.95rem;
      }
      .field input[type="checkbox"] {
        transform: scale(1.1);
      }
      .small-note {
        font-size: 0.82rem;
        color: #6b7280;
        margin-top: 6px;
      }
      #modelPreview {
        margin-top: 8px;
        padding: 12px;
        border-radius: 8px;
        background: #ffffff;
        border: 1px solid #e5e7eb;
        white-space: pre-wrap;
        font-size: 0.85rem;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
        max-height: 360px;
        overflow: auto;
      }
    </style>
  </head>
  <body>
    <header class="topbar">
      <button id="btnBack" class="secondary" onclick="location.href='../'">
        üëà Back to ToolBox
      </button>

      <span class="title">LineMaster 2.4GHz Companion</span>
    </header>

    <h1>LineMaster 2.4GHz Companion</h1>

    <div class="toolbar">
      <button id="btnConnect" class="primary">Connect</button>
      <button id="btnDisconnect" class="secondary" disabled>Disconnect</button>
      <button id="btnList" class="secondary" disabled>Sync SD</button>
      <button id="btnDump" class="secondary" disabled>Dump SD ‚Üí Folder</button>
      <button id="btnToggleLog" class="secondary">Show log</button>
    </div>

    <div id="status">Status: disconnected</div>

    <div class="section-title">Files on SD card</div>
    <div id="files">No files yet. Click ‚ÄúSync SD‚Äù.</div>

    <div class="section-title">File content</div>
    <div id="fileContent">
      <div id="fileContentTitle">No file selected.</div>
      <div id="fileContentBody"></div>
    </div>

    <div class="section-title">Model editor</div>
    <div id="editor" style="display: none">
      <div style="display: flex; gap: 12px; flex-wrap: wrap; align-items: center">
        <button id="btnLoadModel" class="secondary">
          Load selected file as Model JSON
        </button>
        <button id="btnCopyModelJson" class="secondary" disabled>Copy JSON</button>
        <button id="btnDownloadModelJson" class="secondary" disabled>
          Download JSON
        </button>
      </div>

      <div
        id="editorStatus"
        style="margin-top: 8px; color: #4b5563; font-size: 0.9rem"
      >
        No model loaded.
      </div>

      <div id="modelForm" style="margin-top: 12px"></div>

      <div class="section-title">Edited JSON preview</div>
      <div id="modelPreview"></div>
    </div>

    <div class="section-title">Log</div>
    <div id="output"></div>

    <script>
      // --- Global state ---
      let port = null;
      let reader = null;
      let writer = null;
      let buffer = "";

      let fileList = [];

      // Promises for LIST / READ
      let waitForListResolve = null;
      let waitForFileResolve = null;

      // State for current file transfer (line-based)
      let currentFileName = null;
      let currentFileContent = "";
      let listActive = false;

      const textDecoder = new TextDecoder();
      const statusEl = document.getElementById("status");
      const filesEl = document.getElementById("files");
      const outputEl = document.getElementById("output");
      const fileContentTitleEl = document.getElementById("fileContentTitle");
      const fileContentBodyEl = document.getElementById("fileContentBody");

      const btnConnect = document.getElementById("btnConnect");
      const btnDisconnect = document.getElementById("btnDisconnect");
      const btnList = document.getElementById("btnList");
      const btnDump = document.getElementById("btnDump");
      const btnToggleLog = document.getElementById("btnToggleLog");

      let logVisible = false;

      function log(msg) {
        console.log(msg);
        outputEl.textContent += msg + "\n";
        outputEl.scrollTop = outputEl.scrollHeight;
      }

      function setStatus(text) {
        statusEl.textContent = "Status: " + text;
      }

      function setConnectedUI(connected) {
        btnConnect.disabled = connected;
        btnDisconnect.disabled = !connected;
        btnList.disabled = !connected;
        btnDump.disabled = !connected;
      }

      async function connect() {
        try {
          if (!("serial" in navigator)) {
            alert(
              "This browser does not support Web Serial.\nUse Chrome or Edge on desktop."
            );
            return;
          }

          port = await navigator.serial.requestPort();
          await port.open({ baudRate: 115200 });

          setStatus("connected");
          setConnectedUI(true);
          log("Connected to serial port.");

          reader = port.readable.getReader();

          const textEncoder = new TextEncoderStream();
          textEncoder.readable.pipeTo(port.writable);
          writer = textEncoder.writable.getWriter();

          readLoop(); // no await
        } catch (err) {
          console.error(err);
          setStatus("error while connecting");
          log("Error while connecting: " + err);
          port = null;
          reader = null;
          writer = null;
          setConnectedUI(false);
        }
      }

      async function disconnect() {
        try {
          if (reader) {
            await reader.cancel().catch(() => {});
            reader = null;
          }
          if (writer) {
            await writer.close().catch(() => {});
            writer = null;
          }
          if (port) {
            await port.close().catch(() => {});
            port = null;
          }
          setStatus("disconnected");
          setConnectedUI(false);
          log("Disconnected.");
        } catch (err) {
          console.error(err);
          log("Error while disconnecting: " + err);
        }
      }

      async function sendCommand(cmd) {
        if (!writer) {
          throw new Error("No active writer.");
        }
        const line = cmd.trim() + "\n";
        await writer.write(line);
        log(">> " + cmd);
      }

      async function readLoop() {
        buffer = "";
        currentFileName = null;
        currentFileContent = "";
        listActive = false;

        while (port && reader) {
          try {
            const { value, done } = await reader.read();
            if (done) break;
            if (!value) continue;

            const chunk = textDecoder.decode(value, { stream: true });
            buffer += chunk;
            let lines = buffer.split("\n");
            buffer = lines.pop(); // possible partial line

            for (const rawLine of lines) {
              const line = rawLine.replace(/\r$/, "");
              handleIncomingLine(line);
            }
          } catch (err) {
            console.error("Error in readLoop:", err);
            break;
          }
        }

        setStatus("disconnected (read loop ended)");
        setConnectedUI(false);
      }

      function handleIncomingLine(line) {
        if (!line) return;

        if (line === "LIST_BEGIN") {
          log("<< LIST_BEGIN");
          listActive = true;
          fileList = [];
          return;
        }

        if (line === "LIST_END") {
          log("<< LIST_END");
          listActive = false;
          renderFileList();
          if (waitForListResolve) {
            waitForListResolve(fileList);
            waitForListResolve = null;
          }
          return;
        }

        if (line.startsWith("FILE_BEGIN:")) {
          currentFileName = line.substring("FILE_BEGIN:".length).trim();
          currentFileContent = "";
          log("<< FILE_BEGIN: " + currentFileName);
          return;
        }

        if (line.startsWith("FILE_END:")) {
          const endName = line.substring("FILE_END:".length).trim();
          log("<< FILE_END: " + endName);

          if (waitForFileResolve && currentFileName === endName) {
            const result = {
              name: currentFileName,
              content: currentFileContent,
            };
            waitForFileResolve(result);
            waitForFileResolve = null;
          } else if (currentFileName === endName) {
            log(
              "Content of " +
                endName +
                ":\n" +
                (currentFileContent || "(empty file)")
            );
          }

          currentFileName = null;
          currentFileContent = "";
          return;
        }

        // Inside file transfer ‚Üí content
        if (currentFileName !== null) {
          if (currentFileContent.length > 0) {
            currentFileContent += "\n";
          }
          currentFileContent += line;
          return;
        }

        // Normal line
        log("<< " + line);

        // During LIST, treat as file name
        if (listActive) {
          const name = line.trim();
          if (name.length > 0) {
            fileList.push(name);
          }
        }
      }

      function renderFileList() {
        filesEl.innerHTML = "";
        if (!fileList || fileList.length === 0) {
          filesEl.textContent = "No files on SD card or Sync SD not run yet.";
          return;
        }

        for (const fname of fileList) {
          const row = document.createElement("div");
          row.className = "file-row";

          const btnRead = document.createElement("button");
          btnRead.textContent = "READ";
          btnRead.className = "secondary";
          btnRead.onclick = async () => {
            try {
              await readSingleFileAndShow(fname);
            } catch (err) {
              log("Error reading " + fname + ": " + err);
            }
          };

          const nameEl = document.createElement("div");
          nameEl.className = "file-name";
          nameEl.textContent = fname;

          row.appendChild(btnRead);
          row.appendChild(nameEl);
          filesEl.appendChild(row);
        }
      }

      // --- High level helpers ---

      function listFiles() {
        return new Promise(async (resolve, reject) => {
          if (!port || !writer) {
            return reject(new Error("Not connected."));
          }
          waitForListResolve = resolve;
          try {
            await sendCommand("LIST");
          } catch (err) {
            waitForListResolve = null;
            reject(err);
          }
        });
      }

      function readFile(name) {
        return new Promise(async (resolve, reject) => {
          if (!port || !writer) {
            return reject(new Error("Not connected."));
          }
          waitForFileResolve = resolve;
          try {
            await sendCommand("READ " + name);
          } catch (err) {
            waitForFileResolve = null;
            reject(err);
          }
        });
      }

      async function readSingleFileAndShow(name) {
        const result = await readFile(name);
        let text = result.content || "";

        // Try parse JSON & pretty print
        let formatted = text;
        try {
          const obj = JSON.parse(text);
          formatted = JSON.stringify(obj, null, 2);
        } catch (e) {
          // leave as-is
        }

        fileContentTitleEl.textContent = "File: " + result.name;
        fileContentBodyEl.textContent = formatted || "(empty file)";

        // Capture as "selected file" for editor
        selectedFileName = result.name;
        selectedFileRawText = text;
        editorEl.style.display = "block";
        editorStatusEl.textContent =
          'Selected file: ' +
          selectedFileName +
          '. Click "Load selected file as Model JSON".';
      }

      async function dumpSdToFolder() {
        if (!("showDirectoryPicker" in window)) {
          alert(
            "Your browser does not support the File System Access API.\nUse Chrome or Edge on desktop."
          );
          return;
        }
        if (!port || !writer) {
          alert("Connect to the ESP32 first.");
          return;
        }

        try {
          const dirHandle = await window.showDirectoryPicker();
          log("Folder selected for SD dump.");

          log("Requesting LIST from SD...");
          const files = await listFiles();
          if (!files || files.length === 0) {
            log("No files on SD card.");
            return;
          }
          log("Files found: " + files.join(", "));

          let saved = 0;
          let failed = 0;

          for (const fname of files) {
            try {
              log("Reading file: " + fname);
              const result = await readFile(fname);

              const contentToWrite = result.content || "";

              let safeName = fname.replace(/[<>:"/\\|?*]/g, "_");
              if (!safeName) safeName = "file.txt";

              if (fname === "preferences.cfg") {
                safeName = "preferences.txt";
              }

              log("Writing file on local disk: " + safeName);
              const fileHandle = await dirHandle.getFileHandle(safeName, {
                create: true,
              });
              const writable = await fileHandle.createWritable();
              await writable.write(contentToWrite);
              await writable.close();
              saved++;
            } catch (err) {
              failed++;
              log("Error saving " + fname + ": " + err);
            }
          }

          const msg =
            "SD dump completed.\nSaved: " +
            saved +
            " file(s)\nFailed: " +
            failed +
            " file(s)";
          alert(msg);
        } catch (err) {
          console.error(err);
          log("Error in Dump SD ‚Üí Folder: " + err);
        }
      }

      function toggleLogVisibility() {
        logVisible = !logVisible;
        outputEl.style.display = logVisible ? "block" : "none";
        btnToggleLog.textContent = logVisible ? "Hide log" : "Show log";
      }

      // --- UI events ---
      btnConnect.onclick = () => connect();
      btnDisconnect.onclick = () => disconnect();

      btnList.onclick = async () => {
        try {
          await listFiles();
        } catch (err) {
          log("Error running LIST: " + err);
        }
      };

      btnDump.onclick = () => {
        dumpSdToFolder();
      };

      btnToggleLog.onclick = () => {
        toggleLogVisibility();
      };

      // ===============================
      // Model Editor (web-only, no SD write yet)
      // ===============================
      const editorEl = document.getElementById("editor");
      const modelFormEl = document.getElementById("modelForm");
      const modelPreviewEl = document.getElementById("modelPreview");
      const editorStatusEl = document.getElementById("editorStatus");
      const btnLoadModel = document.getElementById("btnLoadModel");
      const btnCopyModelJson = document.getElementById("btnCopyModelJson");
      const btnDownloadModelJson = document.getElementById("btnDownloadModelJson");

      let selectedFileName = null;
      let selectedFileRawText = null;
      let currentModelObj = null;

      function safeGet(obj, path, fallback) {
        try {
          const v = path.split(".").reduce((acc, key) => acc[key], obj);
          return v === undefined || v === null ? fallback : v;
        } catch {
          return fallback;
        }
      }

      function safeSet(obj, path, value) {
        const keys = path.split(".");
        let cur = obj;
        for (let i = 0; i < keys.length - 1; i++) {
          const k = keys[i];
          if (typeof cur[k] !== "object" || cur[k] === null) cur[k] = {};
          cur = cur[k];
        }
        cur[keys[keys.length - 1]] = value;
      }

      function renderPreview() {
        if (!currentModelObj) {
          modelPreviewEl.textContent = "";
          return;
        }
        modelPreviewEl.textContent = JSON.stringify(currentModelObj, null, 2);
      }

      function createField({ label, type, value, onChange, note }) {
        const wrap = document.createElement("div");
        wrap.className = "field";

        const lab = document.createElement("label");
        lab.textContent = label;

        if (type === "checkbox") {
          const input = document.createElement("input");
          input.type = "checkbox";
          input.checked = !!value;
          input.onchange = () => onChange(input.checked);
          wrap.appendChild(lab);
          wrap.appendChild(input);
        } else {
          const input = document.createElement("input");
          input.type = type;
          input.value = value ?? "";
          input.oninput = () => {
            if (type === "number") {
              const v = input.value.trim() === "" ? 0 : Number(input.value);
              onChange(Number.isFinite(v) ? v : 0);
            } else {
              onChange(input.value);
            }
          };
          wrap.appendChild(lab);
          wrap.appendChild(input);
        }

        if (note) {
          const n = document.createElement("div");
          n.className = "small-note";
          n.textContent = note;
          wrap.appendChild(n);
        }

        return wrap;
      }

      function createFieldset(title) {
        const fs = document.createElement("div");
        fs.className = "fieldset";
        const t = document.createElement("div");
        t.className = "fieldset-title";
        t.textContent = title;
        const grid = document.createElement("div");
        grid.className = "grid";
        fs.appendChild(t);
        fs.appendChild(grid);
        return { fs, grid };
      }

      function renderChannelGroup(objPath, title, channels) {
        const { fs, grid } = createFieldset(title);

        for (const ch of channels) {
          const path = `${objPath}.${ch}`;
          const val = safeGet(currentModelObj, path, 0);

          const isBool = typeof val === "boolean";
          const type = isBool ? "checkbox" : "number";

          grid.appendChild(
            createField({
              label: ch,
              type,
              value: val,
              onChange: (v) => {
                safeSet(currentModelObj, path, v);
                renderPreview();
              },
            })
          );
        }

        return fs;
      }

      function renderModelForm() {
        modelFormEl.innerHTML = "";
        if (!currentModelObj) return;

        // General
        {
          const { fs, grid } = createFieldset("General");

          grid.appendChild(
            createField({
              label: "name",
              type: "text",
              value: safeGet(currentModelObj, "name", ""),
              onChange: (v) => {
                safeSet(currentModelObj, "name", v);
                renderPreview();
              },
            })
          );

          grid.appendChild(
            createField({
              label: "mac",
              type: "text",
              value: safeGet(currentModelObj, "mac", "00:00:00:00:00:00"),
              onChange: (v) => {
                safeSet(currentModelObj, "mac", v);
                renderPreview();
              },
              note: "Recommended: AA:BB:CC:DD:EE:FF",
            })
          );

          grid.appendChild(
            createField({
              label: "is_binded",
              type: "checkbox",
              value: safeGet(currentModelObj, "is_binded", false),
              onChange: (v) => {
                safeSet(currentModelObj, "is_binded", v);
                renderPreview();
              },
            })
          );

          grid.appendChild(
            createField({
              label: "has_failsafe",
              type: "checkbox",
              value: safeGet(currentModelObj, "has_failsafe", false),
              onChange: (v) => {
                safeSet(currentModelObj, "has_failsafe", v);
                renderPreview();
              },
            })
          );

          grid.appendChild(
            createField({
              label: "throttle_cut",
              type: "number",
              value: safeGet(currentModelObj, "throttle_cut", -100),
              onChange: (v) => {
                safeSet(currentModelObj, "throttle_cut", v);
                renderPreview();
              },
              note: "Default: -100",
            })
          );

          modelFormEl.appendChild(fs);
        }

        const CH = ["ch1", "ch2", "ch3", "ch4", "ch5", "ch6"];
        const RND = ["rnd1", "rnd2", "rnd3", "rnd4", "rnd5"];

        modelFormEl.appendChild(
          renderChannelGroup("failsafe", "Failsafe (ch1..ch6)", CH)
        );
        modelFormEl.appendChild(
          renderChannelGroup("positions", "Positions (ch1..ch6)", CH)
        );
        modelFormEl.appendChild(renderChannelGroup("expo", "Expo (ch1..ch6)", CH));
        modelFormEl.appendChild(
          renderChannelGroup("reverse", "Reverse (ch1..ch6)", CH)
        );

        modelFormEl.appendChild(
          renderChannelGroup("min", "Min (ch1..ch6 + rnd1..rnd5)", [...CH, ...RND])
        );
        modelFormEl.appendChild(renderChannelGroup("mid", "Mid (ch1..ch6)", CH));
        modelFormEl.appendChild(
          renderChannelGroup("max", "Max (ch1..ch6 + rnd1..rnd5)", [...CH, ...RND])
        );
        modelFormEl.appendChild(
          renderChannelGroup("speed", "Speed (ch1..ch6 + rnd1..rnd5)", [
            ...CH,
            ...RND,
          ])
        );

        modelFormEl.appendChild(renderChannelGroup("mode", "Mode (rnd1..rnd5)", RND));
        modelFormEl.appendChild(
          renderChannelGroup("frequency", "Frequency (rnd1..rnd5)", RND)
        );
      }

      function tryLoadSelectedAsModel() {
        if (!selectedFileRawText) {
          editorStatusEl.textContent =
            "No file selected/read yet. Click READ on a file first.";
          return;
        }

        let obj;
        try {
          obj = JSON.parse(selectedFileRawText);
        } catch (e) {
          editorStatusEl.textContent = "Selected file is not valid JSON.";
          currentModelObj = null;
          renderModelForm();
          renderPreview();
          btnCopyModelJson.disabled = true;
          btnDownloadModelJson.disabled = true;
          return;
        }

        const looksLikeModel =
          typeof obj === "object" &&
          obj &&
          "name" in obj &&
          "mac" in obj &&
          "min" in obj &&
          "max" in obj;

        currentModelObj = obj;

        editorEl.style.display = "block";
        editorStatusEl.textContent = looksLikeModel
          ? "Model loaded from: " + selectedFileName
          : "JSON loaded, but it doesn't look like a Model config.";

        renderModelForm();
        renderPreview();
        btnCopyModelJson.disabled = false;
        btnDownloadModelJson.disabled = false;
      }

      async function copyModelJson() {
        if (!currentModelObj) return;
        const text = JSON.stringify(currentModelObj, null, 2);
        await navigator.clipboard.writeText(text);
        editorStatusEl.textContent = "JSON copied to clipboard.";
      }

      function downloadModelJson() {
        if (!currentModelObj) return;
        const text = JSON.stringify(currentModelObj, null, 2);
        const blob = new Blob([text], { type: "application/json" });

        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        const base = (currentModelObj.name || "model")
          .toString()
          .trim()
          .replace(/\s+/g, "_");
        a.download = `${base || "model"}_edited.json`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(a.href);

        editorStatusEl.textContent = "JSON downloaded.";
      }

      btnLoadModel.onclick = () => tryLoadSelectedAsModel();
      btnCopyModelJson.onclick = () =>
        copyModelJson().catch((e) => log("Clipboard error: " + e));
      btnDownloadModelJson.onclick = () => downloadModelJson();
    </script>
  </body>
</html>
